"""Import thư viện"""

import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import kneighbors_graph
import torch
import numpy as np
from torch_geometric.data import Data
import torch.nn.functional as F
from torch_geometric.nn import GCNConv
import os
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.manifold import TSNE
from sklearn.decomposition import PCA
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split

"""Đọc dataset được lấy từ: https://www.kaggle.com/datasets/amauricio/pe-files-malwares"""

data_malware = pd.read_csv('D:\\project\\IE105\\GNN_For_PE_File\\dataset_malwares.csv')
data_test = pd.read_csv('D:\\project\\IE105\\GNN_For_PE_File\\dataset_test.csv')

data_malware.head(5)

data_malware.info()

dropped_data_malware = data_malware.drop(['Name', 'Machine', 'TimeDateStamp', 'Malware'], axis=1)

plt.figure(figsize=(8, 6))
data_malware['Malware'].value_counts().plot.bar()
plt.xticks([1,0], ['Benign', 'Malware'])
plt.xlabel('Malware')
plt.ylabel('Count')
plt.title('Biểu đồ phân lớp dữ liệu')
plt.show()

features_1 = ['MajorSubsystemVersion', 'MajorLinkerVersion', 'SizeOfCode', 'SizeOfImage', 'SizeOfHeaders', 'SizeOfInitializedData',
           'SizeOfUninitializedData', 'SizeOfStackReserve', 'SizeOfHeapReserve',
            'NumberOfSymbols', 'SectionMaxChar']
i=1

for features_1 in features_1:
    plt.figure(figsize=(10, 15))
    ax1 = plt.subplot(len(features_1), 2, i)
    sns.distplot(data_malware[data_malware['Malware']==1][features_1], ax=ax1, kde_kws={'bw': 0.1})
    ax1.set_title(f'Malware', fontsize=10)
    ax2 = plt.subplot(len(features_1), 2, i+1)
    sns.distplot(data_malware[data_malware['Malware']==0][features_1], ax=ax2, kde_kws={'bw': 0.1})
    ax2.set_title(f'Benign', fontsize=10)
    i= i+2

# Columns in the dataset
columns = data_malware.columns.tolist()

# Identify feature columns (exclude 'Name' and 'Malware')
feature_columns = [col for col in columns if col in ['MajorSubsystemVersion', 'MajorLinkerVersion', 'SizeOfCode', 'SizeOfImage', 'SizeOfHeaders', 'SizeOfInitializedData',
           'SizeOfUninitializedData', 'SizeOfStackReserve', 'SizeOfHeapReserve',
            'NumberOfSymbols', 'SectionMaxChar']]

# Label column
label_column = 'Malware'

# Print the identified feature columns
print(f"Feature columns: {feature_columns}")
print(f"Label column: {label_column}")

#Chuan hoa cac tinh nang
scaler = StandardScaler()
features = scaler.fit_transform(data_malware[feature_columns])
labels = data_malware[label_column].values
# Áp dụng SMOTE để cân bằng dữ liệu
smote = SMOTE(random_state=42)
features_resampled, labels_resampled = smote.fit_resample(features, labels)

k = 5
try:
    knn_graph = kneighbors_graph(features_resampled, k, mode='connectivity', include_self=False)
    print(f"Shape of knn_graph: {knn_graph.shape}")
    edge_index = torch.tensor(np.array(knn_graph.nonzero()), dtype=torch.long)
    print(f"Shape of edge_index: {edge_index.shape}")
except ValueError as e:
    print(f"Error in kneighbors_graph: {e}")

# Convert features and labels to PyTorch tensors
x = torch.tensor(features_resampled, dtype=torch.float)
y = torch.tensor(labels_resampled, dtype=torch.long)

# Create a PyTorch Geometric Data object
graph_data = Data(x=x, edge_index=edge_index, y=y)

# Create a PyTorch Geometric Data object
graph_data = Data(x=x, edge_index=edge_index, y=y)

tsne = TSNE(n_components=2, random_state=42)
z = tsne.fit_transform(features_resampled)

# Prepare colors for different classes
colors = [1 if label == 1 else 0 for label in labels_resampled]

# Visualize using scatter plot
plt.figure(figsize=(10, 10))
plt.xticks([])
plt.yticks([])
plt.scatter(z[:, 0], z[:, 1], c=colors, cmap="Set2")
plt.title("Visualization of the Dataset")
plt.show()

# Define the GNN model
class GCN(torch.nn.Module):
    def __init__(self, in_channels, out_channels):
        super(GCN, self).__init__()
        self.conv1 = GCNConv(in_channels, 16)
        self.conv2 = GCNConv(16, out_channels)

    def forward(self, data):
        x, edge_index = data.x, data.edge_index
        x = self.conv1(x, edge_index)
        x = F.relu(x)
        x = self.conv2(x, edge_index)
        return F.log_softmax(x, dim=1)

# Initialize the model, optimizer, and loss function
model = GCN(in_channels=graph_data.num_features, out_channels=2)
optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
criterion = torch.nn.CrossEntropyLoss()

# Training the GNN model
def train():
    model.train()
    optimizer.zero_grad()
    out = model(graph_data)
    loss = criterion(out, graph_data.y)
    loss.backward()
    optimizer.step()
    return loss

# Test the GNN model
def test():
  model.eval()
  out = model(graph_data)
  pred = out.argmax(dim=1)
  test_correct = pred[graph_data.test_mask] == graph_data.y[graph_data.test_mask]
  test_acc = int(test_correct.sum()) / int(graph_data.test_mask.sum())
  return test_acc

# Training loop
for epoch in range(500):
    loss = train()
    if epoch % 20 == 0:
        print(f'Epoch {epoch}, Loss: {loss:.4f}')

# Giả sử graph_data.y là nhãn của các nút/mẫu
num_nodes = graph_data.num_nodes  # Số lượng nút/mẫu trong đồ thị
indices = list(range(num_nodes))  # Tạo danh sách các chỉ số

# Phân chia thành 80% train và 20% test
train_indices, test_indices = train_test_split(indices, test_size=0.2, random_state=42, stratify=graph_data.y)


# Giả sử bạn đã chia dữ liệu thành các phần train và test
# Tạo test_mask với các giá trị True/False tương ứng với các mẫu thuộc tập test
test_mask = torch.zeros(graph_data.num_nodes, dtype=torch.bool)
test_mask[test_indices] = True  # test_indices là các chỉ số của các mẫu thuộc tập test

# Gán mask này vào graph_data
graph_data.test_mask = test_mask

test_acc = test()
print(f'Test Accuracy: {test_acc:.4f}')

#%matplotlib inline

def visualize(h):
  z = TSNE(n_components=2).fit_transform(h.detach().cpu().numpy())

  # Visualize using scatter plot
  plt.figure(figsize=(10, 10))
  plt.xticks([])
  plt.yticks([])
  plt.scatter(z[:, 0], z[:, 1], c=colors, cmap="Set2")
  plt.title("Visualization of the Dataset")
  plt.show()

model.eval()

out = model(graph_data)
visualize(out)

# Save the trained model
model_save_path = 'D:\\project\\IE105\\GNN_For_PE_File\\trained_gcn_model.pth'
optimizer_save_path = 'D:\\project\\IE105\\GNN_For_PE_File\\optimizer.pth'

torch.save(model.state_dict(), model_save_path)
torch.save(optimizer.state_dict(), optimizer_save_path)

print("Model saved successfully.")

# To load the model later
loaded_model = GCN(in_channels=graph_data.num_features, out_channels=2)
loaded_optimizer = torch.optim.Adam(loaded_model.parameters(), lr=0.01)

loaded_model.load_state_dict(torch.load(model_save_path))
loaded_optimizer.load_state_dict(torch.load(optimizer_save_path))

print("Model loaded successfully.")

scaler = StandardScaler()
scaler.fit(data_test[feature_columns])  # Assuming 'data' is the training dataset DataFrame
test_features = scaler.transform(data_test[feature_columns])

# Columns in the dataset
columns_test = data_test.columns.tolist()

# Identify feature columns (exclude 'Name' and 'Malware')
feature_columns_test = [col for col in columns_test if col in ['MajorSubsystemVersion', 'MajorLinkerVersion', 'SizeOfCode', 'SizeOfImage', 'SizeOfHeaders', 'SizeOfInitializedData',
           'SizeOfUninitializedData', 'SizeOfStackReserve', 'SizeOfHeapReserve',
            'NumberOfSymbols', 'SectionMaxChar']]

scaler = StandardScaler()
scaler.fit(data_malware[feature_columns])  # Giả sử bạn đã fit scaler trên dữ liệu train
test_features = scaler.transform(data_test[feature_columns_test])

k = 5
try:
    knn_graph_test = kneighbors_graph(test_features, k, mode='connectivity', include_self=False)
    print(f"Shape of knn_graph: {knn_graph.shape}")
    test_edge_index = torch.tensor(np.array(knn_graph.nonzero()), dtype=torch.long)
    print(f"Shape of edge_index: {edge_index.shape}")
except ValueError as e:
    print(f"Error in kneighbors_graph: {e}")

# Convert features and labels to PyTorch tensors
test_x = torch.tensor(test_features, dtype=torch.float)

# Create a PyTorch Geometric Data object
test_graph_data = Data(x=test_x, edge_index=test_edge_index)

# Đảm bảo rằng mô hình của bạn đã được load như sau:
loaded_model.eval()

# Dự đoán
with torch.no_grad():
    out = loaded_model(test_graph_data)
    predictions = out.argmax(dim=1)

# Chuyển đổi dự đoán thành định dạng bạn mong muốn (ví dụ: numpy array)
predictions = predictions.cpu().numpy()

# Giả sử bạn muốn lưu kết quả thành CSV
result_df = pd.DataFrame(predictions, columns=["Predicted_Label"])
result_df.to_csv("D:\\project\\IE105\\GNN_For_PE_File\\test_predictions.csv", index=False)